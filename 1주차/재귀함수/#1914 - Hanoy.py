#1914back.py
# 문제
# 세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.

# 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
# 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.
# 이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.

# 아래 그림은 원판이 5개인 경우의 예시이다.



# 입력
# 첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 100)이 주어진다.

# 출력
# 첫째 줄에 옮긴 횟수 K를 출력한다.

# N이 20 이하인 입력에 대해서는 두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다. N이 20보다 큰 경우에는 과정은 출력할 필요가 없다.

# 입력
# 첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 100)이 주어진다.

# 출력
# 첫째 줄에 옮긴 횟수 K를 출력한다.

# N이 20 이하인 입력에 대해서는 두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다. N이 20보다 큰 경우에는 과정은 출력할 필요가 없다.

# 예제 입력 1 
# 3
# 예제 출력 1 
# 7
# 1 3
# 1 2
# 3 2
# 1 3
# 2 1
# 2 3
# 1 3


################################################################
#
#   논리 1
#   2. 재귀함수 이용
def move(no:int, x:int, y:int)->None:
    if no > 1:
        move(no-1,x,6-x-y)
    print(f'원반 [{no}]을 {x}기둥에서 {y}기둥으로 옮깁니다.')
    if no > 1:
        move(no-1,6-x-y,y)
        
#move(int(input()),1,3)

################################################################################
#
# -> 시간 초과 : 글로벌변수에 접근하는 방법이 원인일 것이라 예상
#
str = ""
cnt = 0 
def _move(no:int, x:int, y:int):
    global cnt
    global str
    if no > 1:
        _move(no-1,x,6-x-y)
    cnt+=1
    str+=f'{x} {y}\n'
    if no > 1:
        _move(no-1,6-x-y,y)
# _move(int(input()),1,3)
# print(cnt)
# print(str)

################################################################################
#
# 메모리 초과 ㅠㅠ -> 변수를 최대한 선언하지 않고 해결해보자
#
str = ""
def _move2(no:int, x:int, y:int):
    cnt = 0
    str=""
    if no > 1:
        temp = _move2(no-1,x,6-x-y)
        cnt+= temp[0]
        str+= temp[1]
    cnt+=1
    str+=f'{x} {y}\n'
    if no > 1:
        temp = _move2(no-1,6-x-y,y) 
        cnt+=temp[0]
        str+=temp[1]
    return cnt,str
# temp = _move2(int(input()),1,3)
# print(temp[0])
# print(temp[1])

################################################################################
#
# 생각해보니 cnt 를 굳이 같이 셀 필요가 없다.. 
# 리스트에 담아서 개수를 출력하면 될것.. 
#
def _move3(no:int, x:int, y:int):
    list = []
    if no > 1:
        list+=_move3(no-1,x,6-x-y)
    list+=[f'{x} {y}\n']
    if no > 1:
        list+=_move3(no-1,6-x-y,y)
    return list 
# list = _move3(int(input()),1,3)
# print(len(list))
# print("".join([x for x in list]))

######################################################################################
#
# -> N이 최대 100이므로 1267650600228229401496703205376개의 연산이 필요하다.. 
#    파이선 기준 6*3+2 = 20 초안에 통과가 안되므로 20 까지만 연산하게끔 제약을걸고 
#    이동 횟수는 공식 2**n-1개를 이용하여 해결하자 ... 
#
#  -> 그동안의 오류는 문제의 조건을 제대로 읽지 않아서 생김ㅠ

def _move3(no:int, x:int, y:int):
    list = []
    if no > 1:
        list+=_move3(no-1,x,6-x-y)
    list+=[f'{x} {y}\n']
    if no > 1:
        list+=_move3(no-1,6-x-y,y)
    return list 
num=  int(input()) 
print(2**num-1)
if num <= 20 : 
    list = _move3(num,1,3)
    print("".join([x for x in list]))


