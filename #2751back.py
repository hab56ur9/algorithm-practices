#2751back.py
# N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.

# 입력
# 첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.

# 출력
# 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

############################################################################
#
# 논리 1 
# 1. 숫자를 정렬하므로 가장 빠른 정렬은 기수정렬
# 2. 하지만 정수 범위이므로 음수가 포함되며 기수정렬은 음수 판별 불가 
# 3. 최대 입력 인덱스가 2,000,001 이다 ( -1,000,000 ~ 1,000,000 까지)
# 4. 정렬 여부보다 시간 초과에 더 주의 해야함 .

def insert_sort(arr):
    n = len(arr)

    for i in range(1,n):
        pointer= i 
        value = arr[i]
        j = i-1 
        while j >= 0 and value < arr[j]:
            arr[j+1] = arr[j]
            j-=1
        arr[j+1] = value
                

list= []
cnt = int(input())
for i in range(cnt):
    list+=[int(input())]
insert_sort(list)
for i in range(cnt):
    print(list[i])

################################################################################
#
# 일반적인 정렬을 활용하는 방법은 제대로 정렬이 되고있다 하더라도
# 시간초과가 나기 쉽다. 특히 이런 넓은 범위를 파이선으로 다루고자 한다면 말이다. 
# 아래 방법은 파이선 특징을 이용하여 굉장히 답을 낼 수 있다.
# 다만 파이선에 너무 종속적인 방법이고 문제 출제의도와는 맞지 않은 것 같다. 

def sol():
    a=[None]*2000001
    b=map(int,open(0))
    next(b)
    for i in b:a[i]=1
    print("\n".join(str(i) for i in range(-1000000,1000001,1) if a[i]))

sol()
